<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Garlic Model: Validation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/peymanmortazavi/garlic-models" title="Garlic Model GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_garlic-models_garlic-models_docs_pages_Validation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Validation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the part of the library that allows validating a data container is valid!</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Why not use JSON Schema?</h1>
<p>There is actually a plan to digest JSON Schema as well, this library just provides a way to define constraints and enforce them. So one could build a JSON schema parser that makes these constraints and then we could test the validity of any data container.</p>
<p>This library focuses on working with <a class="el" href="md__home_runner_work_garlic-models_garlic-models_docs_pages_Layer.html">garlic layers</a> for validation meaning you can test against any type that conforms to <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> and that could include std::vector, RapidJSON types and your own custom types so long as you make wrappers for them.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Constraint</h1>
<p>A constraint is the smallest unit of validation, a constraint should take a layer and say if it is valid or not. It has two primary methods.</p>
<ul>
<li><b><a class="el" href="classgarlic_1_1Constraint.html#a4fdc5068efb70772e885ce52d100157f" title="Very similar to Constraint::test() but it only returns a boolean.">garlic::Constraint::quick_test()</a></b> which is to run as fast as possible and only return a boolean value. <code>true</code> means valid, <code>false</code> means invalid.</li>
<li><b><a class="el" href="classgarlic_1_1Constraint.html#a78ae5860e10589138d30fefe8104ee9d" title="Perform the constraint test on the layer and return the result.">garlic::Constraint::test()</a></b> which is to return a <a class="el" href="structgarlic_1_1ConstraintResult.html" title="Result of a constriant test.">garlic::ConstraintResult</a> that can provide more details including a message.</li>
</ul>
<p>There are finite set of constraints and there is documentation for them in <a class="el" href="constraints_8h.html" title="Contains constraints, built-in constraint tags, fields and models.">garlic/constraints.h</a></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> regex = garlic::make_constraint&lt;garlic::regex_tag&gt;(<span class="stringliteral">&quot;\\d{1,3});</span></div>
</div><!-- fragment --><p>While this may seem like a clunky way to create these constraints, using the documentation and knowing the convention helps a lot to make it easier to work with these.</p>
<p>Every constraint has a <code>name</code>, <code>message</code> in case it fails and whether or not it is <code>fatal</code>. It just means if there are three constraints next to each other, if one of them fails, we break the loop. Otherwise, you continue despite the failure. This will make more sense as you read through this documentation.</p>
<blockquote class="doxtable">
<p><b>NOTE:</b> Every call to <a class="el" href="constraints_8h.html#ab092fe8be61488b61ea4bee14afce412" title="Create a generic Constraint based on a constraint tag.">garlic::make_constraint()</a> can <b>optionally</b> end with <code>name</code>, <code>custom message</code> and <code>fatal</code> args. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="keyword">auto</span> age = make_constraint&lt;regex_tag&gt;(<span class="stringliteral">&quot;\\d{1,3}&quot;</span>, <span class="stringliteral">&quot;age_constraint&quot;</span>, <span class="stringliteral">&quot;Invalid Age!&quot;</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>You can then use a constraint to validate any type conforming to <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a></p>
<div class="fragment"><div class="line"><a class="code" href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">CloveDocument</a> clove;</div>
<div class="line">JsonDocument json;</div>
<div class="line"> </div>
<div class="line">age.quick_test(clove);</div>
<div class="line">age.quick_test(json);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> result = age.test(clove); !result) {</div>
<div class="line">  std::cout &lt;&lt; result.reason &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>a <a class="el" href="classgarlic_1_1Constraint.html" title="Smallest unit of data validation.">garlic::Constraint</a> is like a std::shared_ptr, copying it only copies a pointer to an inner context.</dd></dl>
<p><a class="el" href="classgarlic_1_1Constraint.html" title="Smallest unit of data validation.">garlic::Constraint</a> does not have any constructor, you instead need to either use <a class="el" href="classgarlic_1_1Constraint.html#a44a17f2bcb09ee649ba2118b11391a71" title="Create a generic Constraint based on a constraint tag.">garlic::Constraint::make</a> or use a more convenient shortcut <a class="el" href="constraints_8h.html#ab092fe8be61488b61ea4bee14afce412" title="Create a generic Constraint based on a constraint tag.">garlic::make_constraint()</a>.</p>
<p>If you need to make an empty (null context really) constraint, you can use <a class="el" href="classgarlic_1_1Constraint.html#af0ad8ad6af4e34d790fd2948a84c8309" title="Make a Constraint without any context.">garlic::Constraint::empty()</a> but be careful, passing an empty constraint is like passing a nullptr, it can cause crashes if not handled properly.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> constraint = <a class="code" href="classgarlic_1_1Constraint.html#af0ad8ad6af4e34d790fd2948a84c8309">garlic::Constraint::empty</a>();</div>
<div class="line"><span class="keywordflow">if</span> (...) {  <span class="comment">// using the empty() method is really to cover cases like this.</span></div>
<div class="line">  constraint = garlic::make_constraint&lt;garlic::range_tag&gt;(10, 25);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (constraint)  <span class="comment">// check if constraint is initialized</span></div>
<div class="line">  <span class="keyword">auto</span> result = constraint.quick_test(...);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Field</h1>
<p>A <a class="el" href="classgarlic_1_1Field.html" title="A named group of Constraint elements.">garlic::Field</a> is just a group of constraints stored in a single entity with meta data and some properties.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> user_name = garlic::make_field(<span class="stringliteral">&quot;User Name&quot;</span>);</div>
<div class="line">user_name-&gt;add_constraint(garlic::make_constraint&lt;garlic::regex_tag&gt;(<span class="stringliteral">&quot;\\w{3,12}&quot;</span>));</div>
<div class="line">user_name-&gt;add_constraint&lt;<a class="code" href="structgarlic_1_1regex__tag.html">garlic::regex_tag</a>&gt;(<span class="stringliteral">&quot;\\w{3,12}&quot;</span>);  <span class="comment">// more convenient</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> strict_user_name = garlic::make_field(<span class="stringliteral">&quot;Strict User Name&quot;</span>, {... list of constraints...});</div>
<div class="line">strict_user_name-&gt;inherit_constraints_from(user_name);</div>
</div><!-- fragment --><p>Fields can have meta data which is basically a dictionary mapping strings to strings. </p><div class="fragment"><div class="line">user_name-&gt;meta()[<span class="stringliteral">&quot;message&quot;</span>] = <span class="stringliteral">&quot;Custom message when a field fails!&quot;</span>;</div>
<div class="line">user_name-&gt;meta()[<span class="stringliteral">&quot;db/type] = &quot;</span>VARCHAR<span class="stringliteral">&quot;;</span></div>
</div><!-- fragment --><p>That meta data is meant to be used to store arbitrary information so it can be used for future tools to generate other formats like making migration scripts, or build html forms.</p>
<p>If you set a field to ignore details, it'll return a leaf <a class="el" href="structgarlic_1_1ConstraintResult.html" title="Result of a constriant test.">garlic::ConstraintResult</a> without any details from its inner constraints. This is helpful when you want to use a Field as a constraint that is made of other constraints. For instance, you can pack a bunch of constraints that together validate whether a user name is valid not, but the resulting constraint should only say "invalid username.".</p>
<div class="fragment"><div class="line">user_name-&gt;set_ignore_details(<span class="keyword">true</span>);  <span class="comment">// default is false.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31"></a>
Model</h1>
<p>A <a class="el" href="classgarlic_1_1Model.html" title="An object to describe a Model.">garlic::Model</a> is a way to describe an object's structure. It is essentially a mapping of keys to a field descriptor object.</p>
<p><code>key -&gt; { required: bool, field: std::shared_ptr&lt;<a class="el" href="classgarlic_1_1Field.html" title="A named group of Constraint elements.">garlic::Field</a>&gt; }</code></p>
<p>For example, imagine a User object that must have a username and a phone number but phone is optional.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> user_model = garlic::make_model(<span class="stringliteral">&quot;User&quot;</span>);</div>
<div class="line">user_model-&gt;add_field(<span class="stringliteral">&quot;username&quot;</span>, user_name);  <span class="comment">// user_name from previous section.</span></div>
<div class="line">user_model-&gt;add_field(<span class="stringliteral">&quot;phone&quot;</span>,</div>
<div class="line">                      garlic::make_field({garlic::make_constraint&lt;garlic::regex_tag&gt;(<span class="stringliteral">&quot;regex pattern&quot;</span>)}),</div>
<div class="line">                      <span class="keyword">false</span>);  <span class="comment">// false here indicates the field is NOT required.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">CloveDocument</a> doc;  <span class="comment">// some arbitrary document.</span></div>
<div class="line"><span class="keyword">auto</span> result = user_model-&gt;validate(doc);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Model and Field Tags</h2>
<p>You can make constraints that validate a model or a field. See <a class="el" href="structgarlic_1_1field__tag.html" title="Constraint Tag that passes if the specified Field passes the layer.">garlic::field_tag</a> and <a class="el" href="structgarlic_1_1model__tag.html" title="Constraint Tag that passes if the specified Model passes the layer.">garlic::model_tag</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// ignore details regardless of what &#39;user_name&#39; field&#39;s ignore detail settings.</span></div>
<div class="line"><span class="keyword">auto</span> field_constraint = garlic::make_constraint&lt;garlic::field_tag&gt;(user_name, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model_constraint = garlic::make_constraint&lt;garlic::model_tag&gt;(user_model);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Module</h2>
<p>Now a <a class="el" href="classgarlic_1_1Module.html" title="A Module is a repository of models, fields and constraints.">garlic::Module</a> is simply a repository that contains a bunch of models and fields.</p>
<div class="fragment"><div class="line"><a class="code" href="classgarlic_1_1Module.html">garlic::Module</a> module;</div>
<div class="line">module-&gt;<a class="code" href="classgarlic_1_1Module.html#ab1710bfa02f96f8c21b6b302e5f64f89">add_field</a>(garlic::make_field(<span class="stringliteral">&quot;UserName&quot;</span>));</div>
<div class="line">module-&gt;<a class="code" href="classgarlic_1_1Module.html#ab1710bfa02f96f8c21b6b302e5f64f89">add_field</a>(<span class="stringliteral">&quot;SomeAliasName&quot;</span>, module-&gt;<a class="code" href="classgarlic_1_1Module.html#afdc90b2a7d90ce6e097640b050b36ce8">get_field</a>(<span class="stringliteral">&quot;UserName&quot;</span>));</div>
<div class="line">module-&gt;<a class="code" href="classgarlic_1_1Module.html#ad9a2b2a41ad17084712f62c2a3e87126">add_model</a>(garlic::make_model(<span class="stringliteral">&quot;User&quot;</span>));</div>
</div><!-- fragment --><p>The idea is that you can make a module from a layer. Meaning you could load a module from a JSON, Yaml, MessagePack or whatever layer you have.</p>
<div class="fragment"><div class="line">FILE* module_file = fopen(<span class="stringliteral">&quot;module.json&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> json_doc = garlic::providers::rapidjson::Json::load(module_file);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result = <a class="code" href="parsing_2module_8h.html#a735bd6cb519d51825dc05eeabca5ef0f">garlic::parsing::load_module</a>(json_doc);</div>
<div class="line"><span class="keywordflow">if</span> (!result) {</div>
<div class="line">  std::cout &lt;&lt; result.error().message() &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// handle error here.</span></div>
<div class="line">} </div>
<div class="line"><span class="keyword">auto</span> user_model = result-&gt;get_model(<span class="stringliteral">&quot;User&quot;</span>);</div>
</div><!-- fragment --><p>See <a class="el" href="parsing_2module_8h.html" title="Resources for parsing/loading and dumping Module instances.">garlic/parsing/module.h</a></p>
<p>There is a plan to build module parsers that read JSON schema and other means like maybe defining a set of python files that describe these models.</p>
<p>Curious about the format of this module? <a class="el" href="md__home_runner_work_garlic-models_garlic-models_docs_pages_ModuleParsing.html">See Module Definitions</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassgarlic_1_1Module_html"><div class="ttname"><a href="classgarlic_1_1Module.html">garlic::Module</a></div><div class="ttdoc">A Module is a repository of models, fields and constraints.</div><div class="ttdef"><b>Definition:</b> module.h:41</div></div>
<div class="ttc" id="aclassgarlic_1_1Module_html_ad9a2b2a41ad17084712f62c2a3e87126"><div class="ttname"><a href="classgarlic_1_1Module.html#ad9a2b2a41ad17084712f62c2a3e87126">garlic::Module::add_model</a></div><div class="ttdeci">tl::expected&lt; void, std::error_code &gt; add_model(model_pointer model) noexcept</div><div class="ttdef"><b>Definition:</b> module.h:78</div></div>
<div class="ttc" id="aclove_8h_html_a510118787dcd3f227971552ffa69d6f7"><div class="ttname"><a href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">garlic::CloveDocument</a></div><div class="ttdeci">GenericCloveDocument&lt; CAllocator &gt; CloveDocument</div><div class="ttdoc">A clove document (value) conforming to garlic::RefLayer.</div><div class="ttdef"><b>Definition:</b> clove.h:525</div></div>
<div class="ttc" id="aparsing_2module_8h_html_a735bd6cb519d51825dc05eeabca5ef0f"><div class="ttname"><a href="parsing_2module_8h.html#a735bd6cb519d51825dc05eeabca5ef0f">garlic::parsing::load_module</a></div><div class="ttdeci">static tl::expected&lt; Module, std::error_code &gt; load_module(Layer &amp;&amp;layer) noexcept</div><div class="ttdoc">Loads a Module from any layer.</div><div class="ttdef"><b>Definition:</b> module.h:401</div></div>
<div class="ttc" id="aclassgarlic_1_1Module_html_afdc90b2a7d90ce6e097640b050b36ce8"><div class="ttname"><a href="classgarlic_1_1Module.html#afdc90b2a7d90ce6e097640b050b36ce8">garlic::Module::get_field</a></div><div class="ttdeci">field_pointer get_field(const text &amp;name) const noexcept</div><div class="ttdef"><b>Definition:</b> module.h:136</div></div>
<div class="ttc" id="aclassgarlic_1_1Module_html_ab1710bfa02f96f8c21b6b302e5f64f89"><div class="ttname"><a href="classgarlic_1_1Module.html#ab1710bfa02f96f8c21b6b302e5f64f89">garlic::Module::add_field</a></div><div class="ttdeci">tl::expected&lt; void, std::error_code &gt; add_field(text &amp;&amp;alias, field_pointer field) noexcept</div><div class="ttdef"><b>Definition:</b> module.h:92</div></div>
<div class="ttc" id="astructgarlic_1_1regex__tag_html"><div class="ttname"><a href="structgarlic_1_1regex__tag.html">garlic::regex_tag</a></div><div class="ttdoc">Constraint Tag that passes if a specified regex pattern passes the test.</div><div class="ttdef"><b>Definition:</b> constraints.h:539</div></div>
<div class="ttc" id="aclassgarlic_1_1Constraint_html_af0ad8ad6af4e34d790fd2948a84c8309"><div class="ttname"><a href="classgarlic_1_1Constraint.html#af0ad8ad6af4e34d790fd2948a84c8309">garlic::Constraint::empty</a></div><div class="ttdeci">static Constraint empty() noexcept</div><div class="ttdoc">Make a Constraint without any context.</div><div class="ttdef"><b>Definition:</b> constraints.h:293</div></div>
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
