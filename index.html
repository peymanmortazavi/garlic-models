<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Garlic Model: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/peymanmortazavi/garlic-models" title="Garlic Model GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A data container protocol and schema validation for C++ 20</p>
<blockquote class="doxtable">
<p>Currently this is only working for GCC 10 and C++ 20 but other compilers will be supported. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md34"></a>
What is this?</h1>
<p>This library provides three things:</p>
<h2><a class="anchor" id="autotoc_md35"></a>
1. Data Container Protocol</h2>
<p>Woooah what a buzz word. It's just two C++ concepts to provide a common interface so that various different data containers could be described using a set of methods.</p>
<p>Long story short, most JSON and YAML libraries you find are probably going to have ways to get strings, numbers, booleans, lists and objects. What if we make a contract that designates one interface that includes a common set of functions these libraries provide. Then we can wrap these types with adapters so they all have same methods then we can write code agnostic to what library we're working with.</p>
<p>This is mostly to make the schema validation available to a variety of different formats and libraries that hold data similar to JSON, YAML, XML, MessagePack, etc.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;garlic::ViewLayer Layer&gt;</div>
<div class="line"><span class="keywordtype">void</span> iterate_over_lists(Layer&amp;&amp; layer) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : layer.get_list()) {</div>
<div class="line">        <span class="keywordflow">if</span> (!item.is_string())</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        std::cout &lt;&lt; item.get_string_view() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://peymanmortazavi.github.io/garlic-models/md__home_runner_work_garlic-models_garlic-models_docs_pages_Layer.html">Read More About This</a></p>
<h2><a class="anchor" id="autotoc_md36"></a>
2. Schema Validation to validate data containers</h2>
<p>There is a constraint system you can work with. The plan is to add parsers for JSON Schema and other formats to enable the developers use whatever format they like.</p>
<p>But there is also a built-in format for describing models and schemas.</p>
<p>Consider the following code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> username_constraint = garlic::make_constraint&lt;garlic::regex_tag&gt;(<span class="stringliteral">&quot;\\w{3,12}&quot;</span>);</div>
<div class="line"> </div>
<div class="line">rapidjson::Document json_doc;  <span class="comment">// say you have a RapidJSON document.</span></div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> result = username_constraint.test(JsonView(json_doc)); !result) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid username: &quot;</span> &lt;&lt; result.reason &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">yaml_document_t* yaml_doc;  <span class="comment">// say you have a yaml_document_t;</span></div>
<div class="line"><span class="keywordflow">if</span> (!username_constraint.quick_test(YamlView(yaml_doc))) {  <span class="comment">// don&#39;t care about details.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid username!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can also define all these models, fields and constraints in a YAML or JSON file and load a module.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Load the module file using libyaml and store it in a CloveDocument.</span></div>
<div class="line">    FILE* module_file = fopen(<span class="stringliteral">&quot;models.yaml&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">    <a class="code" href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">garlic::CloveDocument</a> doc;</div>
<div class="line">    garlic::providers::libyaml::load(module_file, doc);</div>
<div class="line">    fclose(module_file);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get a garlic::Module out of that! you can use any layer type here.</span></div>
<div class="line">    <span class="comment">// So long as it conforms to garlic::ViewLayer</span></div>
<div class="line">    <span class="keyword">auto</span> result = <a class="code" href="parsing_2module_8h.html#a735bd6cb519d51825dc05eeabca5ef0f">garlic::parsing::load_module</a>(doc);</div>
<div class="line">    <span class="keywordflow">if</span> (!result) {</div>
<div class="line">        std::cout &lt;&lt; result.error().message() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Say you want to load a config file for your http server.</span></div>
<div class="line">    <span class="comment">// Get the model HttpConfig from the module, this would be defined in your module file.</span></div>
<div class="line">    <span class="keyword">auto</span> config_model = result-&gt;get_model(<span class="stringliteral">&quot;HttpConfig&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load the config file using rapidjson.</span></div>
<div class="line">    FILE* config_file = fopen(<span class="stringliteral">&quot;configs.json&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> configs = garlic::providers::rapidjson::Json::load(config_file);</div>
<div class="line">    fclose(config_file);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Validate the configs.</span></div>
<div class="line">    <span class="keyword">auto</span> validation_results = config_model-&gt;validate(configs);</div>
<div class="line">    <span class="keywordflow">if</span> (!validation_results) {</div>
<div class="line">        std::cout &lt;&lt; validation_results.reason &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Hey you have good configs! nice going!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// maybe decode the configs into something useful.</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The nice thing is that these wrappers likely get optimized away, leaving very minimal cost to this abstraction.</p>
<p><a href="https://peymanmortazavi.github.io/garlic-models/md__home_runner_work_garlic-models_garlic-models_docs_pages_Validation.html">Read More</a></p>
<h2><a class="anchor" id="autotoc_md37"></a>
3. Encoding Utilities to serialize and deserialize custom C++ classes and types.</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    std::string name;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;garlic::ViewLayer Layer&gt;</div>
<div class="line">    <span class="keyword">static</span> User decode(Layer&amp;&amp; layer) {</div>
<div class="line">        <span class="keywordflow">return</span> User {</div>
<div class="line">            .name = garlic::get&lt;std::string&gt;(layer, <span class="stringliteral">&quot;name&quot;</span>)</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Group {</div>
<div class="line">    std::vector&lt;User&gt; users;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;garlic::ViewLayer Layer&gt;</div>
<div class="line">    <span class="keyword">static</span> Group decode(Layer&amp;&amp; layer) {</div>
<div class="line">        Group group;</div>
<div class="line">        std::for_each(</div>
<div class="line">            layer.begin_list(), layer.end_list(),</div>
<div class="line">            [&amp;group](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value) {</div>
<div class="line">                group.users.emplace_back(garlic::decode&lt;User&gt;(value));</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">garlic::CloveDocument</a> doc;</div>
<div class="line"> </div>
<div class="line">    FILE* file = fopen(<span class="stringliteral">&quot;data.yaml&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">    garlic::providers::libyaml::load(file, doc);  <span class="comment">// use libyaml to populate CloveDocument.</span></div>
<div class="line"> </div>
<div class="line">    Group group = garlic::decode&lt;Group&gt;(doc);  <span class="comment">// parse Group from CloveDocument.</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://peymanmortazavi.github.io/garlic-models/md__home_runner_work_garlic-models_garlic-models_docs_pages_Encoding.html">Read More</a></p>
<h1><a class="anchor" id="autotoc_md38"></a>
What's missing?</h1>
<ul>
<li>There's just more work to be done to make this ready for production use and there are still parts that might change since they're not battle tested.</li>
<li>There is only support for RapidJSON and some limited support for libyaml and yaml-cpp. More libraries need to be supported before this library can be really used by users who don't use RapidJSON in their code.</li>
<li>Currently only GCC 10 and C++ 20 is supported. We can work on the source code to bring that down to at least C++ 17 and support more compilers. This is just very alpha at the moment.</li>
<li>More tests and performance benchmarks to make sure this library is actually fast.</li>
<li>Compilation takes forever! This is going to become annoying. There are ways to improve this.</li>
<li>Better documentation, there are some but not sure if it's good to set someone up their way.</li>
</ul>
<h1><a class="anchor" id="autotoc_md39"></a>
How do I play with this?</h1>
<p>You can either use the docker-compose file in the <code>docker</code> directory to compile all tests and lab.cpp or if you have GCC 10 and C++ 20 around, you can just compile lab.cpp and take it for a ride!</p>
<p>You might want to disable running tests in <code>tests/CMakeLists.txt</code> if that long compilation bothers you.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Performance Tests</h1>
<p>Just don't run them :) they're not ready but if you do, run the following commands beforehand.</p>
<div class="fragment"><div class="line">sudo cpupower frequency-set --governor performance</div>
<div class="line"># run your performance tests.</div>
<div class="line">sudo cpupower frequency-set --governor powersave</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclove_8h_html_a510118787dcd3f227971552ffa69d6f7"><div class="ttname"><a href="clove_8h.html#a510118787dcd3f227971552ffa69d6f7">garlic::CloveDocument</a></div><div class="ttdeci">GenericCloveDocument&lt; CAllocator &gt; CloveDocument</div><div class="ttdoc">A clove document (value) conforming to garlic::RefLayer.</div><div class="ttdef"><b>Definition:</b> clove.h:502</div></div>
<div class="ttc" id="aparsing_2module_8h_html_a735bd6cb519d51825dc05eeabca5ef0f"><div class="ttname"><a href="parsing_2module_8h.html#a735bd6cb519d51825dc05eeabca5ef0f">garlic::parsing::load_module</a></div><div class="ttdeci">static tl::expected&lt; Module, std::error_code &gt; load_module(Layer &amp;&amp;layer) noexcept</div><div class="ttdoc">Loads a Module from any layer.</div><div class="ttdef"><b>Definition:</b> module.h:404</div></div>
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
