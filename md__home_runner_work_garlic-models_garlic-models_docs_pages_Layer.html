<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Garlic Model: Layer / Data Container Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/peymanmortazavi/garlic-models" title="Garlic Model GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_garlic-models_garlic-models_docs_pages_Layer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Layer / Data Container Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The whole idea of this library got started because I wanted to build a schema validation library but it obviously had to work with multiple JSON and Yaml libraries because people use different libraries and some make their own.</p>
<p>How do we make this library work for other folks? we make a wrapper! This is nothing new, there are already some other libraries that do a very similar thing if not the same to accomplish this.</p>
<p>This libraries tries to use concepts and provide easy ways to establish some sort of contract for all these wrappers without relying on any virtual tables so we can remain fast and yet provide a somewhat easy way to make wrappers for arbitrary data containers.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
What's the benefit?</h1>
<ul>
<li>Use schema validation in this library to validate data represented by various different data containers.</li>
<li>You could acutally make your code agnostic to what library you use for data containers (JSON, Yaml, etc.) This way you could rely on different libraries for different architectures if needed without modifying your code much.</li>
<li>Depending on capabilities of the data container, you could pay almost no cost for this abstraction.</li>
</ul>
<p><b>The two main concepts are <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> and <a class="el" href="classgarlic_1_1RefLayer.html" title="Concept for reading from and writing to containers.">garlic::RefLayer</a></b> and the idea is that you either want a read-only layer to be able to consume values from it or you want to be able to write to it as well. <a class="el" href="classgarlic_1_1RefLayer.html" title="Concept for reading from and writing to containers.">garlic::RefLayer</a> is a <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> that has writing methods as well.</p>
<p>These concepts define the bare-minimum set of functions and type alises to make a layer readable. But some layers have additional optional features. You can take adventage of these as well.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rapidjson/document.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="encoding_8h.html">garlic/encoding.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;garlic/providers/rapidjson.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> garlic::providers::rapidjson::JsonView;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Config {</div>
<div class="line">   std::string host;</div>
<div class="line">   <span class="keywordtype">unsigned</span> port;</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">template</span>&lt;GARLIC_VIEW Layer&gt;</div>
<div class="line">   <span class="keyword">static</span> Config decode(Layer&amp;&amp; layer) {</div>
<div class="line">      Config config;</div>
<div class="line">      config.host = <a class="code" href="utility_8h.html#ac4bed02fbe5380778b5295cdca1b89f2">garlic::get</a>(layer, <span class="stringliteral">&quot;hostname&quot;</span>, <span class="stringliteral">&quot;localhost&quot;</span>);</div>
<div class="line">      config.port = <a class="code" href="utility_8h.html#ac4bed02fbe5380778b5295cdca1b89f2">garlic::get</a>(layer, <span class="stringliteral">&quot;port&quot;</span>, 5000);</div>
<div class="line">      <span class="keywordflow">return</span> config;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">   rapidjson::Document doc;  <span class="comment">// use a rapidjson document.</span></div>
<div class="line">   <span class="keyword">auto</span> config = garlic::decode&lt;Config&gt;(JsonView(doc));</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a class="el" href="md__home_runner_work_garlic-models_garlic-models_docs_pages_Encoding.html">Encoding Documentation</a> for more details.</p>
<p>As you can see in the above example, you can use a wrapper or a <em>provider</em> for RapidJSON, a populate and fast JSON library to populate a custom class. Because of this concept, as long as you can provide these wrappers for your data containers you can use them with garlic for schema validation and encoding/decoding. You don't have to change your decoding logic for your Config yet you can support reading files from MessagePack, JSON and Yaml and even your own custom containers. In many instances including the example above, compiler might optimize away all these wrappers giving you a near zero cost for this abstraction.</p>
<p>You will see a lot of <code>View</code>, <code>Reference</code> and <code>Value</code> or <code>Document</code> in garlic.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
View</h2>
<p>View is similar to std::string_view in that it is simply a view object. You can wrap various different data container types using a view wrapper like <code>JsonView</code> for RapidJSON and call your generic methods that know how to read from a <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a>. This is ideal for the following situation:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> load_config(<span class="keyword">const</span> rapidjson::Value&amp; value) {</div>
<div class="line">   <span class="comment">// you only have access to a const reference.</span></div>
<div class="line">   <span class="keyword">auto</span> config = Config::decode(JsonView(value));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> load_config(<span class="keyword">const</span> yaml_document_t* doc) {</div>
<div class="line">   <span class="comment">// you only have access to a const libyaml document pointer.</span></div>
<div class="line">   <span class="keyword">auto</span> config = Config::decode(YamlView(doc));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Reference</h2>
<p>Reference is similar to passing a value by reference but in this case a small wrapper object carries the reference.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;GARLIC_REF Layer&gt;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> write_config(Layer&amp;&amp; layer, <span class="keyword">const</span> Config&amp; config) {</div>
<div class="line">   layer.set_object();</div>
<div class="line">   layer.add_member(<span class="stringliteral">&quot;hostname&quot;</span>, config.host.c_str());</div>
<div class="line">   layer.add_member(<span class="stringliteral">&quot;port&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(config.port));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> save_json_config(rapidjson::Value&amp; value, <span class="keyword">const</span> Config&amp; config) {</div>
<div class="line">   write_config(JsonRef(value), config);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><p>Why is this reference needed? mostly so you don't own an object and also because using iterators would have to return references but obviously it would have to be a wrapper type conforming to <a class="el" href="classgarlic_1_1RefLayer.html" title="Concept for reading from and writing to containers.">garlic::RefLayer</a></p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Layer&gt;</div>
<div class="line">add_bonus(Layer&amp;&amp; layer) {</div>
<div class="line">   <span class="keywordtype">unsigned</span> score = 0;</div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keyword">auto</span> item : layer.get_list()) {  <span class="comment">// item is a reference object!</span></div>
<div class="line">      item.set_int(item.get_int() + 10);</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main () {</div>
<div class="line">   rapidjson::Document doc;  <span class="comment">// assume it&#39;s a list of numbers.</span></div>
<div class="line">   add_bonus(JsonRef(doc));</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, it's a bit counter-intuitive that item in the for loop is actually an object you can pass by value cheaply since it's just a reference and is likely to get optimized away. But the important part is that because that is a wrapper object that holds a reference to inner rapidjson::Value instances, it cannot bind to lvalue references in for loops like in the example.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Document and Value</h2>
<p>Value is an object that actually manages and holds a data container inside it. You can avoid using rapidjson types altogether and use garlic providers instead.</p>
<p>Document is similar to <em>Value</em> but in some libraries a <em>Document</em> manages the allocations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;garlic/providers/rapidjson.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> garlic::providers::rapidjson::JsonDocument;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">   JsonDocument doc;  <span class="comment">// uses a ::rapidjson::Document internally.</span></div>
<div class="line">   Config config{<span class="stringliteral">&quot;localhost&quot;</span>, 4000};</div>
<div class="line">   <span class="comment">// we don&#39;t use wrappers here. JsonDocument is already a wrapper conforming to garlic::RefLayer.</span></div>
<div class="line">   write_config(doc, config);</div>
<div class="line">   <span class="keyword">auto</span>&amp; inner_rapidjson_doc = doc.get_inner_value();  <span class="comment">// refrence to the inner ::rapidjson::Document</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>There are a very limited set of providers at the moment but the list will grow with time. You can help making them!</p>
<blockquote class="doxtable">
<p>There is an existing data container that one can use without relying on any library. See <a class="el" href="clove_8h.html" title="Built-in type that provides readable and writable layers.">garlic/clove.h</a> </p>
</blockquote>
<p>That might be a good choice with libyaml because it occupies less memory than <code>yaml_document_t</code> and it is faster when getting numbers and boolean values because yaml_document_t only holds strings and everytime you use <code>get_int()</code>, <code>get_double()</code> or <code>get_bool()</code> a conversion from string to the related type has to happen.</p>
<blockquote class="doxtable">
<p><b>NOTE</b> Take a look at the <a class="el" href="utility_8h.html" title="This file contains various functions and classes to work with layers like getting or resolving using ...">garlic/utility.h</a> for some utility functions you can use with any type conforming to layer concepts. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aencoding_8h_html"><div class="ttname"><a href="encoding_8h.html">encoding.h</a></div><div class="ttdoc">Contains classes and methods for defining and using encoders/decoders for various types.</div></div>
<div class="ttc" id="autility_8h_html_ac4bed02fbe5380778b5295cdca1b89f2"><div class="ttname"><a href="utility_8h.html#ac4bed02fbe5380778b5295cdca1b89f2">garlic::get</a></div><div class="ttdeci">static OutputType get(Layer &amp;&amp;layer, IndexType index, OutputType default_value)</div><div class="ttdef"><b>Definition:</b> utility.h:372</div></div>
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
