<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<title>Garlic Model: garlic/utility.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/peymanmortazavi/garlic-models" title="Garlic Model GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('utility_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utility.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains various functions and classes to work with layers like getting or resolving using a path.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;charconv&gt;</code><br />
<code>#include &lt;string_view&gt;</code><br />
<code>#include &quot;meta.h&quot;</code><br />
<code>#include &quot;<a class="el" href="encoding_8h_source.html">encoding.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for utility.h:</div>
<div class="dyncontent">
<div class="center"><img src="utility_8h__incl.png" border="0" usemap="#garlic_2utility_8h" alt=""/></div>
<map name="garlic_2utility_8h" id="garlic_2utility_8h">
<area shape="rect" title="This file contains various functions and classes to work with layers like getting or resolving using ..." alt="" coords="157,5,268,32"/>
<area shape="rect" title=" " alt="" coords="5,80,87,107"/>
<area shape="rect" title=" " alt="" coords="111,80,208,107"/>
<area shape="rect" href="meta_8h_source.html" title=" " alt="" coords="232,80,300,107"/>
<area shape="rect" href="encoding_8h.html" title="Contains classes and methods for defining and using encoders/decoders for various types." alt="" coords="366,80,459,107"/>
<area shape="rect" title=" " alt="" coords="142,155,209,181"/>
<area shape="rect" title=" " alt="" coords="219,229,278,256"/>
<area shape="rect" title=" " alt="" coords="284,155,376,181"/>
<area shape="rect" href="layer_8h.html" title="This file contains concepts for C++ 20 along with some helper types to make it easier to produce iter..." alt="" coords="401,155,467,181"/>
<area shape="rect" href="containers_8h.html" title="Supporting containers for the garlic model." alt="" coords="529,155,632,181"/>
<area shape="rect" title=" " alt="" coords="304,229,375,256"/>
<area shape="rect" title=" " alt="" coords="399,229,469,256"/>
<area shape="rect" title=" " alt="" coords="494,229,561,256"/>
<area shape="rect" title=" " alt="" coords="585,229,651,256"/>
<area shape="rect" title=" " alt="" coords="675,229,753,256"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="utility_8h__dep__incl.png" border="0" usemap="#garlic_2utility_8hdep" alt=""/></div>
<map name="garlic_2utility_8hdep" id="garlic_2utility_8hdep">
<area shape="rect" title="This file contains various functions and classes to work with layers like getting or resolving using ..." alt="" coords="327,5,437,32"/>
<area shape="rect" href="constraints_8h.html" title="Contains constraints, built&#45;in constraint tags, fields and models." alt="" coords="161,87,307,114"/>
<area shape="rect" href="garlic_8h_source.html" title=" " alt="" coords="5,244,116,271"/>
<area shape="rect" href="module_8h.html" title="A repository of models, fields and constraints that can be serialized/deserialized." alt="" coords="321,169,443,196"/>
<area shape="rect" href="parsing_2module_8h.html" title="Resources for parsing/loading and dumping Module instances." alt="" coords="295,244,469,271"/>
<area shape="rect" href="yaml-cpp_8h_source.html" title=" " alt="" coords="518,80,678,121"/>
<area shape="rect" href="parsing_2constraints_8h_source.html" title=" " alt="" coords="97,169,296,196"/>
</map>
</div>
</div>
<p><a href="utility_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgarlic_1_1lazy__string__splitter.html">garlic::lazy_string_splitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy string splitter for getting tokens one by one.  <a href="classgarlic_1_1lazy__string__splitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4dd27d9b9b615303dbd8c3c60f53be22"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW L1, GARLIC_VIEW L2&gt; </td></tr>
<tr class="memitem:a4dd27d9b9b615303dbd8c3c60f53be22"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt;!is_comparable&lt; L1, L2 &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a4dd27d9b9b615303dbd8c3c60f53be22">garlic::cmp_layers</a> (const L1 &amp;layer1, const L2 &amp;layer2)</td></tr>
<tr class="memdesc:a4dd27d9b9b615303dbd8c3c60f53be22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the equality of two layers.  <a href="utility_8h.html#a4dd27d9b9b615303dbd8c3c60f53be22">More...</a><br /></td></tr>
<tr class="separator:a4dd27d9b9b615303dbd8c3c60f53be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617d7424f15ce61fb41446e33b787788"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW LayerType, typename Callable &gt; </td></tr>
<tr class="memitem:a617d7424f15ce61fb41446e33b787788"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a617d7424f15ce61fb41446e33b787788">garlic::resolve_layer_cb</a> (const LayerType &amp;value, std::string_view path, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:a617d7424f15ce61fb41446e33b787788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad23e63a2d400e6c23d5e76bf66586e"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:afad23e63a2d400e6c23d5e76bf66586e"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#afad23e63a2d400e6c23d5e76bf66586e">garlic::safe_resolve</a> (const Layer &amp;value, std::string_view key, OutputType default_value)</td></tr>
<tr class="separator:afad23e63a2d400e6c23d5e76bf66586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72b447f47218b67345ad1a6f39a6e68"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </td></tr>
<tr class="memitem:ab72b447f47218b67345ad1a6f39a6e68"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#ab72b447f47218b67345ad1a6f39a6e68">garlic::safe_resolve_cb</a> (const Layer &amp;value, std::string_view key, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:ab72b447f47218b67345ad1a6f39a6e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561466333596999d0bb55ddb4e55a7c1"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a561466333596999d0bb55ddb4e55a7c1"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a561466333596999d0bb55ddb4e55a7c1">garlic::resolve</a> (const Layer &amp;value, std::string_view key, OutputType default_value)</td></tr>
<tr class="separator:a561466333596999d0bb55ddb4e55a7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb4f9bc8911144b5558d9d375ba59c8"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </td></tr>
<tr class="memitem:acfb4f9bc8911144b5558d9d375ba59c8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#acfb4f9bc8911144b5558d9d375ba59c8">garlic::resolve_cb</a> (const Layer &amp;value, std::string_view key, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:acfb4f9bc8911144b5558d9d375ba59c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5006ab12b1f2039c67f742a9ca96d1cf"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer, typename Callable &gt; </td></tr>
<tr class="memitem:a5006ab12b1f2039c67f742a9ca96d1cf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a5006ab12b1f2039c67f742a9ca96d1cf">garlic::get_member</a> (const Layer &amp;value, const char *key, Callable &amp;&amp;cb) noexcept</td></tr>
<tr class="separator:a5006ab12b1f2039c67f742a9ca96d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e63946aa4dd4d5ffc03569fd538f32"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer, typename Callable &gt; </td></tr>
<tr class="memitem:aa7e63946aa4dd4d5ffc03569fd538f32"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#aa7e63946aa4dd4d5ffc03569fd538f32">garlic::get_member</a> (const Layer &amp;value, std::string_view key, Callable &amp;&amp;cb) noexcept</td></tr>
<tr class="separator:aa7e63946aa4dd4d5ffc03569fd538f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa04219f3b883ba9175597d901f85f"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:a1ffa04219f3b883ba9175597d901f85f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::__is_random_access_iter&lt; ConstValueIteratorOf&lt; Layer &gt; &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a1ffa04219f3b883ba9175597d901f85f">garlic::get_item</a> (Layer &amp;&amp;layer, IndexType index, Callable &amp;&amp;cb) noexcept</td></tr>
<tr class="separator:a1ffa04219f3b883ba9175597d901f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d862d6858398925095a5aeeb6f363c0"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a8d862d6858398925095a5aeeb6f363c0"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a8d862d6858398925095a5aeeb6f363c0">garlic::get</a> (Layer &amp;&amp;layer, const char *key)</td></tr>
<tr class="separator:a8d862d6858398925095a5aeeb6f363c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0aa73b3ac23e8220b1515747b24abb"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </td></tr>
<tr class="memitem:a9a0aa73b3ac23e8220b1515747b24abb"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::__is_random_access_iter&lt; ConstValueIteratorOf&lt; Layer &gt; &gt;::value, OutputType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a9a0aa73b3ac23e8220b1515747b24abb">garlic::get</a> (Layer &amp;&amp;layer, IndexType index)</td></tr>
<tr class="separator:a9a0aa73b3ac23e8220b1515747b24abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199cda8a3460f5978a559eec1ca0f287"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a199cda8a3460f5978a559eec1ca0f287"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a199cda8a3460f5978a559eec1ca0f287">garlic::get</a> (Layer &amp;&amp;layer, const char *key, OutputType default_value)</td></tr>
<tr class="separator:a199cda8a3460f5978a559eec1ca0f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bed02fbe5380778b5295cdca1b89f2"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </td></tr>
<tr class="memitem:ac4bed02fbe5380778b5295cdca1b89f2"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#ac4bed02fbe5380778b5295cdca1b89f2">garlic::get</a> (Layer &amp;&amp;layer, IndexType index, OutputType default_value)</td></tr>
<tr class="separator:ac4bed02fbe5380778b5295cdca1b89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740ed7ffa5b0d30cb79215b5e2d126a"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , typename Callable , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:af740ed7ffa5b0d30cb79215b5e2d126a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#af740ed7ffa5b0d30cb79215b5e2d126a">garlic::get_cb</a> (Layer &amp;&amp;layer, const char *key, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:af740ed7ffa5b0d30cb79215b5e2d126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb726b09f0ae1fa9c7b7623d9b904b1c"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:acb726b09f0ae1fa9c7b7623d9b904b1c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#acb726b09f0ae1fa9c7b7623d9b904b1c">garlic::get_cb</a> (Layer &amp;&amp;layer, IndexType index, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:acb726b09f0ae1fa9c7b7623d9b904b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55262a00ca6aecc256d12e69f27b2259"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a55262a00ca6aecc256d12e69f27b2259"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a55262a00ca6aecc256d12e69f27b2259">garlic::safe_get</a> (Layer &amp;&amp;layer, const char *key, OutputType default_value)</td></tr>
<tr class="separator:a55262a00ca6aecc256d12e69f27b2259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e8770da4b2e2a03dbc068b2eae601"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </td></tr>
<tr class="memitem:a710e8770da4b2e2a03dbc068b2eae601"><td class="memTemplItemLeft" align="right" valign="top">static OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a710e8770da4b2e2a03dbc068b2eae601">garlic::safe_get</a> (Layer &amp;&amp;layer, IndexType index, OutputType default_value)</td></tr>
<tr class="separator:a710e8770da4b2e2a03dbc068b2eae601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5dacf093e1e38cde74c9c13ed774b7"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </td></tr>
<tr class="memitem:aef5dacf093e1e38cde74c9c13ed774b7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#aef5dacf093e1e38cde74c9c13ed774b7">garlic::safe_get_cb</a> (Layer &amp;&amp;layer, const char *key, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:aef5dacf093e1e38cde74c9c13ed774b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0889f1349f9272adf6e6ccaa29ce2af"><td class="memTemplParams" colspan="2">template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:ad0889f1349f9272adf6e6ccaa29ce2af"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#ad0889f1349f9272adf6e6ccaa29ce2af">garlic::safe_get_cb</a> (Layer &amp;&amp;layer, IndexType index, Callable &amp;&amp;cb)</td></tr>
<tr class="separator:ad0889f1349f9272adf6e6ccaa29ce2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4098cb2598656db969e6e6d856696c37"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer, GARLIC_REF Output&gt; </td></tr>
<tr class="memitem:a4098cb2598656db969e6e6d856696c37"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a4098cb2598656db969e6e6d856696c37">garlic::copy_layer</a> (Layer &amp;&amp;layer, Output output)</td></tr>
<tr class="separator:a4098cb2598656db969e6e6d856696c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6894295e94080fcf3108a14b9a148ba4"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a6894295e94080fcf3108a14b9a148ba4"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a6894295e94080fcf3108a14b9a148ba4">garlic::list_size</a> (Layer &amp;&amp;layer)</td></tr>
<tr class="memdesc:a6894295e94080fcf3108a14b9a148ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a list from a layer.  <a href="utility_8h.html#a6894295e94080fcf3108a14b9a148ba4">More...</a><br /></td></tr>
<tr class="separator:a6894295e94080fcf3108a14b9a148ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d939cf3ff41baa7bf44ae723cf445cd"><td class="memTemplParams" colspan="2">template&lt;GARLIC_VIEW Layer&gt; </td></tr>
<tr class="memitem:a8d939cf3ff41baa7bf44ae723cf445cd"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="utility_8h.html#a8d939cf3ff41baa7bf44ae723cf445cd">garlic::string_length</a> (Layer &amp;&amp;layer)</td></tr>
<tr class="memdesc:a8d939cf3ff41baa7bf44ae723cf445cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a string from a layer.  <a href="utility_8h.html#a8d939cf3ff41baa7bf44ae723cf445cd">More...</a><br /></td></tr>
<tr class="separator:a8d939cf3ff41baa7bf44ae723cf445cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains various functions and classes to work with layers like getting or resolving using a path. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4dd27d9b9b615303dbd8c3c60f53be22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd27d9b9b615303dbd8c3c60f53be22">&#9670;&nbsp;</a></span>cmp_layers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW L1, GARLIC_VIEW L2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;!is_comparable&lt;L1, L2&gt;::value, bool&gt; garlic::cmp_layers </td>
          <td>(</td>
          <td class="paramtype">const L1 &amp;&#160;</td>
          <td class="paramname"><em>layer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L2 &amp;&#160;</td>
          <td class="paramname"><em>layer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the equality of two layers. </p>
<p>If the equality operator is defined or simply if <b>layer1 == layer2</b> is valid, this function just returns the result of that comparison. This is done for performance reasons.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the size of these two types, this method could be quite expensive as it performs a linear scan on both layers for members and lists.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer1</td><td>The first layer, any type that conforms to the <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> concept. </td></tr>
    <tr><td class="paramname">layer2</td><td>The second layer, any type that conforms to the <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> concept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4098cb2598656db969e6e6d856696c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4098cb2598656db969e6e6d856696c37">&#9670;&nbsp;</a></span>copy_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer, GARLIC_REF Output&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::copy_layer </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deep copies the content of one layer to another.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Layer</td><td>any type that conforms to <a class="el" href="classgarlic_1_1ViewLayer.html" title="Concept for reading values from containers.">garlic::ViewLayer</a> concept. </td></tr>
    <tr><td class="paramname">Output</td><td>any type that conforms to <a class="el" href="classgarlic_1_1RefLayer.html" title="Concept for reading from and writing to containers.">garlic::RefLayer</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The source view layer to copy values from. </td></tr>
    <tr><td class="paramname">output</td><td>The destination ref layer to copy values to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d862d6858398925095a5aeeb6f363c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d862d6858398925095a5aeeb6f363c0">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> value associated with the given key in the layer.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object nor that it has the key. </dd></dl>

</div>
</div>
<a id="a199cda8a3460f5978a559eec1ca0f287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199cda8a3460f5978a559eec1ca0f287">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> value associated with the given key in the layer, if found.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object. </dd></dl>

</div>
</div>
<a id="a9a0aa73b3ac23e8220b1515747b24abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0aa73b3ac23e8220b1515747b24abb">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;std::__is_random_access_iter&lt;ConstValueIteratorOf&lt;Layer&gt; &gt;::value, OutputType&gt; garlic::get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> <em>i</em> th element in the layer.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is a list nor that it has <em>i</em> elements in it. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the view layer supports random access iterators, this is an O(1) function otherwise it's an O(n) function. </dd></dl>

</div>
</div>
<a id="ac4bed02fbe5380778b5295cdca1b89f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bed02fbe5380778b5295cdca1b89f2">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> <em>i</em> th element in the layer, if found.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is a list. </dd></dl>

</div>
</div>
<a id="af740ed7ffa5b0d30cb79215b5e2d126a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af740ed7ffa5b0d30cb79215b5e2d126a">&#9670;&nbsp;</a></span>get_cb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , typename Callable , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::get_cb </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the <b>decoded</b> value associated with the given key in the layer, if found.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb726b09f0ae1fa9c7b7623d9b904b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb726b09f0ae1fa9c7b7623d9b904b1c">&#9670;&nbsp;</a></span>get_cb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::get_cb </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the <b>decoded</b> <em>i</em> th element in the layer, if found.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is a list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ffa04219f3b883ba9175597d901f85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa04219f3b883ba9175597d901f85f">&#9670;&nbsp;</a></span>get_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;std::__is_random_access_iter&lt;ConstValueIteratorOf&lt;Layer&gt; &gt;::value&gt; garlic::get_item </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the <em>i</em> th element in the layer.</p>
<dl class="section note"><dt>Note</dt><dd>If the view layer supports random access iterators, this is an O(1) function otherwise it's an O(n) function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(LayerType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5006ab12b1f2039c67f742a9ca96d1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5006ab12b1f2039c67f742a9ca96d1cf">&#9670;&nbsp;</a></span>get_member() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::get_member </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the value associated with the given key in the layer, if found.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(LayerType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7e63946aa4dd4d5ffc03569fd538f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e63946aa4dd4d5ffc03569fd538f32">&#9670;&nbsp;</a></span>get_member() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::get_member </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Calls the callback function with the value associated with the given key in the layer, if found.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(LayerType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6894295e94080fcf3108a14b9a148ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6894295e94080fcf3108a14b9a148ba4">&#9670;&nbsp;</a></span>list_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t garlic::list_size </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a list from a layer. </p>
<dl class="section note"><dt>Note</dt><dd>This method does <b>NOT</b> check if the layer is a list type. </dd>
<dd>
Depending on the layer's capabilities, this method chooses the best way to get this count. If the layer has a <a class="el" href="utility_8h.html#a6894295e94080fcf3108a14b9a148ba4" title="Get the size of a list from a layer.">list_size()</a> method or it has random access iterators, this has time complexity of O(1), otherwise it'll be O(n) </dd></dl>

</div>
</div>
<a id="a561466333596999d0bb55ddb4e55a7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561466333596999d0bb55ddb4e55a7c1">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::resolve </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Navigates the layer using the given path and if found returns the <b>decoded</b> value.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>An object path (e.g. users.2.first_name). </td></tr>
    <tr><td class="paramname">default_value</td><td>A default value in case the path does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfb4f9bc8911144b5558d9d375ba59c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb4f9bc8911144b5558d9d375ba59c8">&#9670;&nbsp;</a></span>resolve_cb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::resolve_cb </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Navigates the layer using the given path and if found, calls the callback function with the <b>decoded</b> value.</p>
<p>This method <b>DOES NOT</b> check if the found layer is possible to decode to the <b>OutputType</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>An object path (e.g. users.2.first_name). </td></tr>
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a617d7424f15ce61fb41446e33b787788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617d7424f15ce61fb41446e33b787788">&#9670;&nbsp;</a></span>resolve_layer_cb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW LayerType, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::resolve_layer_cb </td>
          <td>(</td>
          <td class="paramtype">const LayerType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Navigates the layer using the given path and if found, calls the callback function with the found layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>An object path (e.g. users.2.first_name). </td></tr>
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(LayerType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55262a00ca6aecc256d12e69f27b2259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55262a00ca6aecc256d12e69f27b2259">&#9670;&nbsp;</a></span>safe_get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::safe_get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> value associated with the given key in the layer, if found.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object. </dd></dl>

</div>
</div>
<a id="a710e8770da4b2e2a03dbc068b2eae601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710e8770da4b2e2a03dbc068b2eae601">&#9670;&nbsp;</a></span>safe_get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::safe_get </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <b>decoded</b> <em>i</em> th element in the layer, if found.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is a list. </dd></dl>

</div>
</div>
<a id="aef5dacf093e1e38cde74c9c13ed774b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5dacf093e1e38cde74c9c13ed774b7">&#9670;&nbsp;</a></span>safe_get_cb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::safe_get_cb </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the <b>decoded</b> value associated with the given key in the layer, if found.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is an object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0889f1349f9272adf6e6ccaa29ce2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0889f1349f9272adf6e6ccaa29ce2af">&#9670;&nbsp;</a></span>safe_get_cb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, std::integral IndexType, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::safe_get_cb </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the callback function with the <b>decoded</b> <em>i</em> th element in the layer, if found.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>. </p><dl class="section attention"><dt>Attention</dt><dd>This method <b>DOES NOT</b> check if the layer is a list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad23e63a2d400e6c23d5e76bf66586e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad23e63a2d400e6c23d5e76bf66586e">&#9670;&nbsp;</a></span>safe_resolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OutputType garlic::safe_resolve </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Navigates the layer using the given path and if found returns the <b>decoded</b> value.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>An object path (e.g. users.2.first_name). </td></tr>
    <tr><td class="paramname">default_value</td><td>A default value in case the path does not exist or it cannot be decoded to the <b>OutputType</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab72b447f47218b67345ad1a6f39a6e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72b447f47218b67345ad1a6f39a6e68">&#9670;&nbsp;</a></span>safe_resolve_cb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType , GARLIC_VIEW Layer, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void garlic::safe_resolve_cb </td>
          <td>(</td>
          <td class="paramtype">const Layer &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Navigates the layer using the given path and if found calls the callback function with the <b>decoded</b> value.</p>
<p>This method safely checks if the found layer is possible to decode to the <b>OutputType</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>An object path (e.g. users.2.first_name). </td></tr>
    <tr><td class="paramname">cb</td><td>Any callable object/lambda with signature <b>void(OutputType)</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d939cf3ff41baa7bf44ae723cf445cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d939cf3ff41baa7bf44ae723cf445cd">&#9670;&nbsp;</a></span>string_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GARLIC_VIEW Layer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t garlic::string_length </td>
          <td>(</td>
          <td class="paramtype">Layer &amp;&amp;&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a string from a layer. </p>
<dl class="section note"><dt>Note</dt><dd>This method does <b>NOT</b> check if the layer is a string type. </dd>
<dd>
This method relies on the layer's string_length method if provided. Otherwise, it's a simple strlen(layer.get_cstr()) call. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_af30267d1ad5fcde68c5e8495a1d5b8d.html">garlic</a></li><li class="navelem"><a class="el" href="utility_8h.html">utility.h</a></li>
  </ul>
</div>
</body>
</html>
